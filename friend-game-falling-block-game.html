<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ShapeDrop - è½ã¡ç‰©ãƒ‘ã‚ºãƒ«</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å®Œå…¨ç¦æ­¢ */
        html, body { overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
    </style>
</head>
<body class="theme-friend game-mode-fullscreen">
    
    <div class="game-container" id="mainContainer">
        
        <!-- PCç”¨ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆã‚¹ãƒãƒ›ã§ã¯æ¶ˆãˆã‚‹ï¼‰ -->
        <h1 class="game-title" style="margin-bottom:1rem;">ğŸ® ShapeDrop</h1>
        
        <!-- ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ -->
        <div class="puzzle-layout">
            
            <!-- ã€å·¦ã‚«ãƒ©ãƒ ã€‘PCç”¨æ“ä½œèª¬æ˜ & ãƒœã‚¿ãƒ³ -->
            <div class="side-panel-left">
                <button class="game-btn btn-primary" id="pcStartBtn" style="height:50px;">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
                <button class="game-btn btn-secondary" onclick="resetGame()" style="height:50px;">ãƒªã‚»ãƒƒãƒˆ</button>
                
                <!-- æ“ä½œèª¬æ˜ -->
                <div class="key-instruction-box">
                    <div class="key-row"><span class="key-name">â† â†’</span><span>å·¦å³ç§»å‹•</span></div>
                    <div class="key-row"><span class="key-name">â†‘</span><span>å›è»¢</span></div>
                    <div class="key-row"><span class="key-name">â†“</span><span>é«˜é€Ÿè½ä¸‹</span></div>
                    <div class="key-row"><span class="key-name">Space</span><span>ä¸€æ°—ã«è½ä¸‹</span></div>
                </div>

                <a href="friend-game-main.html" class="back-to-portal-button" style="margin:0; width:100%; font-size:0.9rem;">æˆ»ã‚‹</a>
            </div>

            <!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ãƒ©ãƒƒãƒ‘ãƒ¼ï¼ˆPCã§ã¯æ™®é€šã«è¡¨ç¤ºã€ã‚¹ãƒãƒ›ã§ã¯æ¨ªä¸¦ã³ï¼‰ -->
            <div class="mobile-top-area" style="display:contents;">
                
                <!-- ã€ä¸­å¤®ã‚«ãƒ©ãƒ ã€‘ã‚²ãƒ¼ãƒ ç”»é¢ -->
                <div class="canvas-area">
                    <canvas id="gameCanvas"></canvas>
                    
                    <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ -->
                    <div id="gameOver" class="game-over-overlay">
                        <h2 style="color:#ef4444; margin-bottom:1rem; font-size:2rem;">GAME OVER</h2>
                        <p style="font-size:1.2rem; margin-bottom:1.5rem;">Score: <span id="finalScore">0</span></p>
                        <button class="game-btn btn-primary" onclick="resetGame()">ã‚‚ã†ä¸€åº¦</button>
                        <button class="game-btn btn-secondary" onclick="quitGame()" style="margin-top:1rem;">çµ‚äº†ã™ã‚‹</button>
                    </div>
                </div>

                <!-- ã€å³ã‚«ãƒ©ãƒ ã€‘æƒ…å ±ãƒ‘ãƒãƒ« -->
                <div class="side-panel-right">
                    <div class="puzzle-stat-box">
                        <div class="puzzle-stat-label">NEXT</div>
                        <canvas id="pcNextCanvas" width="60" height="60"></canvas>
                    </div>
                    <div class="puzzle-stat-box">
                        <div class="puzzle-stat-label">SCORE</div>
                        <div class="puzzle-stat-value" id="score">0</div>
                    </div>
                    <div class="puzzle-stat-box">
                        <div class="puzzle-stat-label">LEVEL</div>
                        <div class="puzzle-stat-value" id="level">1</div>
                    </div>
                    <div class="puzzle-stat-box">
                        <div class="puzzle-stat-label">LINES</div>
                        <div class="puzzle-stat-value" id="lines">0</div>
                    </div>
                    
                    <!-- ã‚¹ãƒãƒ›ç”¨çµ‚äº†ãƒœã‚¿ãƒ³ -->
                    <button class="mobile-quit-btn" onclick="if(confirm('çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿ')) quitGame()">çµ‚äº†</button>
                </div>
            </div>
        </div>

        <!-- ã€ä¸‹éƒ¨ã€‘ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ -->
        <div class="mobile-pad">
            <button class="pad-btn" id="mobileStartBtn">START</button>
            <button class="pad-btn" id="rotateBtn">â†»</button>
            
            <button class="pad-btn" id="leftBtn">â—€</button>
            <button class="pad-btn" id="downBtn">â–¼</button>
            <button class="pad-btn" id="rightBtn">â–¶</button>
            <button class="pad-btn" id="dropBtn">â¬‡</button>
        </div>
    </div>

    <script>
        // --- ç”»é¢ã‚µã‚¤ã‚ºå›ºå®š (iOSå¯¾ç­–) ---
        function fixViewport() {
            const vh = window.innerHeight;
            document.body.style.height = vh + 'px';
            const container = document.getElementById('mainContainer');
            if(container) container.style.height = vh + 'px';
        }
        window.addEventListener('resize', fixViewport);
        fixViewport();
        document.documentElement.classList.add('game-mode-lock');

        // --- ã‚²ãƒ¼ãƒ è¦ç´  ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('pcNextCanvas'); // ã‚¹ãƒãƒ›ã§ã‚‚ã“ã‚Œã‚’æµç”¨
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const linesEl = document.getElementById('lines');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');

        // è¨­å®š (12åˆ—x20è¡Œ)
        const COLS = 12; 
        const ROWS = 20;
        let BLOCK_SIZE = 24; 

        // ãƒªã‚µã‚¤ã‚ºå‡¦ç†
        function resizeGame() {
            const container = document.querySelector('.canvas-area');
            const w = container.clientWidth;
            const h = container.clientHeight;
            
            // ç¸¦æ¨ªæ¯”ã‚’ç¶­æŒã—ã¦æœ€å¤§åŒ–
            let size = Math.floor(h / ROWS);
            if (size * COLS > w) {
                size = Math.floor(w / COLS);
            }
            
            // ã‚µã‚¤ã‚ºç¢ºå®š
            BLOCK_SIZE = Math.max(10, size); // æœ€ä½10px
            canvas.width = BLOCK_SIZE * COLS;
            canvas.height = BLOCK_SIZE * ROWS;
            
            if(typeof board !== 'undefined') draw();
        }
        window.addEventListener('resize', resizeGame);
        setTimeout(resizeGame, 100);

        // --- ãƒ–ãƒ­ãƒƒã‚¯å®šç¾© (ã‚ªãƒªã‚¸ãƒŠãƒ«è‰²) ---
        const SHAPES = [
            [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[0, 1, 0], [1, 1, 1]], 
            [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]], 
            [[0, 1, 1], [1, 1, 0]], [[1, 1, 0], [0, 1, 1]]
        ];
        const COLORS = ['#06b6d4', '#f59e0b', '#7c3aed', '#3b82f6', '#ec4899', '#10b981', '#ef4444'];

        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let score = 0, lines = 0, level = 1;
        let dropInterval = 1000, lastTime = 0, dropCounter = 0;
        let isPaused = true, isGameOver = false;
        
        let player = {
            matrix: null, x: 0, y: 0, color: '',
            nextMatrix: null, nextColor: ''
        };

        // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ ---
        function generateNext() {
            const id = Math.floor(Math.random() * SHAPES.length);
            return { matrix: SHAPES[id], color: COLORS[id] };
        }

        function playerReset() {
            if (!player.nextMatrix) {
                const p = generateNext(); player.matrix = p.matrix; player.color = p.color;
                const n = generateNext(); player.nextMatrix = n.matrix; player.nextColor = n.color;
            } else {
                player.matrix = player.nextMatrix; player.color = player.nextColor;
                const n = generateNext(); player.nextMatrix = n.matrix; player.nextColor = n.color;
            }
            player.y = 0;
            player.x = (Math.floor(COLS / 2)) - (Math.floor(player.matrix[0].length / 2));
            drawNext();
            
            if (collide(board, player)) {
                isGameOver = true; isPaused = true;
                finalScoreEl.textContent = score;
                gameOverDiv.style.display = 'flex';
            }
        }

        function drawNext() {
            const c = nextCanvas.getContext('2d');
            // èƒŒæ™¯ã‚¯ãƒªã‚¢ (ãƒ¢ãƒã‚¤ãƒ«ç”¨ã«é€æ˜èƒŒæ™¯ã«ã™ã‚‹ã‹ã€CSSã«åˆã‚ã›ã‚‹)
            const isMobile = window.innerWidth <= 768;
            c.fillStyle = isMobile ? '#000' : '#1f2937'; 
            c.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            const m = player.nextMatrix;
            if(!m) return;
            const size = nextCanvas.width / 6;
            const offsetX = (nextCanvas.width - m[0].length * size) / 2;
            const offsetY = (nextCanvas.height - m.length * size) / 2;
            m.forEach((row, y) => {
                row.forEach((val, x) => {
                    if (val) {
                        c.fillStyle = player.nextColor;
                        c.fillRect(x * size + offsetX, y * size + offsetY, size - 1, size - 1);
                    }
                });
            });
        }

        function collide(board, player) {
            const [m, o] = [player.matrix, player];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function draw() {
            ctx.fillStyle = '#000'; // é»’èƒŒæ™¯
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = '#4b5563';
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE-1, BLOCK_SIZE-1);
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE-1, BLOCK_SIZE-1);
                    }
                });
            });
            
            if (player.matrix) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            ctx.fillStyle = player.color;
                            ctx.fillRect((x + player.x) * BLOCK_SIZE, (y + player.y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        }
                    });
                });
            }
        }

        function merge(board, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) board[y + player.y][x + player.x] = 1;
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; }
            }
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function playerRotate(dir) {
            const pos = player.x; let offset = 1; rotate(player.matrix, dir);
            while (collide(board, player)) {
                player.x += offset; offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.x = pos; return; }
            }
        }

        function playerDrop() {
            player.y++;
            if (collide(board, player)) {
                player.y--; merge(board, player); arenaSweep(); playerReset();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            player.x += dir; if (collide(board, player)) player.x -= dir;
        }

        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = board.length - 1; y > 0; --y) {
                for (let x = 0; x < board[y].length; ++x) {
                    if (board[y][x] === 0) continue outer;
                }
                const row = board.splice(y, 1)[0].fill(0); board.unshift(row); ++y; rowCount++;
            }
            if (rowCount > 0) {
                lines += rowCount;
                score += rowCount * 100 * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                
                scoreEl.textContent = score;
                linesEl.textContent = lines;
                levelEl.textContent = level;
            }
        }

        function update(time = 0) {
            if (isPaused || isGameOver) return;
            const deltaTime = time - lastTime; lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) playerDrop();
            draw();
            requestAnimationFrame(update);
        }

        function startGame() {
            if (isPaused) {
                isPaused = false;
                if (!player.matrix) playerReset();
                update();
                document.getElementById('pcStartBtn').textContent = 'å†é–‹';
                document.getElementById('mobileStartBtn').textContent = 'ä¸­';
                document.getElementById('mobileStartBtn').disabled = true;
            }
        }

        function resetGame() {
            board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
            score = 0; lines = 0; level = 1; dropInterval = 1000;
            player.nextMatrix = null;
            isGameOver = false; isPaused = true;
            gameOverDiv.style.display = 'none';
            scoreEl.textContent = 0; linesEl.textContent = 0; levelEl.textContent = 1;
            startGame();
        }

        function quitGame() { location.href = 'friend-game-main.html'; }

        // --- æ“ä½œç³» ---
        let isSoftDropping = false;
        let softDropTimer = null;

        function startSoftDrop() {
            if (isPaused || isSoftDropping) return;
            isSoftDropping = true;
            function loop() {
                if(!isSoftDropping || isPaused) return;
                playerDrop(); draw();
                softDropTimer = setTimeout(loop, 50);
            }
            loop();
        }
        function stopSoftDrop() { isSoftDropping = false; clearTimeout(softDropTimer); }

        function attachBtn(id, action, isHold = false) {
            const btn = document.getElementById(id);
            if(!btn) return;
            const start = (e) => { e.preventDefault(); if(isHold) action.start(); else action(); };
            const end = (e) => { e.preventDefault(); if(isHold) action.stop(); };
            
            btn.addEventListener('mousedown', start);
            btn.addEventListener('touchstart', start, {passive:false});
            if(isHold) {
                btn.addEventListener('mouseup', end);
                btn.addEventListener('mouseleave', end);
                btn.addEventListener('touchend', end);
            }
        }

        attachBtn('leftBtn', () => playerMove(-1));
        attachBtn('rightBtn', () => playerMove(1));
        attachBtn('rotateBtn', () => playerRotate(1));
        attachBtn('downBtn', {start: startSoftDrop, stop: stopSoftDrop}, true);
        attachBtn('dropBtn', () => {
            while(!collide(board, player)) { player.y++; }
            player.y--; merge(board, player); arenaSweep(); playerReset();
        });

        document.getElementById('pcStartBtn')?.addEventListener('click', startGame);
        document.getElementById('mobileStartBtn')?.addEventListener('click', startGame);

        document.addEventListener('keydown', e => {
            if (isPaused || isGameOver) return;
            if (e.keyCode === 37) playerMove(-1);
            if (e.keyCode === 39) playerMove(1);
            if (e.keyCode === 40) startSoftDrop();
            if (e.keyCode === 38) playerRotate(1);
            if (e.keyCode === 32) {
                while(!collide(board, player)) { player.y++; }
                player.y--; merge(board, player); arenaSweep(); playerReset();
            }
        });
        document.addEventListener('keyup', e => { if (e.keyCode === 40) stopSoftDrop(); });

        resizeGame();
        draw();
    </script>
</body>
</html>